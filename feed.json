{"title":"弦上的梦","description":null,"language":"zh-Hans","link":"https://janche.github.io","pubDate":"Sun, 08 Mar 2020 14:08:37 GMT","lastBuildDate":"Sun, 08 Mar 2020 14:11:01 GMT","generator":"hexo-generator-json-feed","webMaster":"Janche","items":[{"title":"spring-boot项目引入第三方依赖，如何打包","link":"https://janche.github.io/2020/03/08/spring-boot项目引入第三方依赖，如何打包/","description":"项目环境： spring-boot maven多模块项目 需要引入的外部jar包 目录结构图如下：","pubDate":"Sun, 08 Mar 2020 14:08:37 GMT","guid":"https://janche.github.io/2020/03/08/spring-boot项目引入第三方依赖，如何打包/","category":"springboot,引入外部依赖"},{"title":"UTC、GMT、时间戳之间的关系","link":"https://janche.github.io/2020/03/08/UTC、GMT、时间戳之间的关系/","description":"时区世界时区的划分以本初子午线为标准，向东12个时区，向西12个时区，子午线所在区为0时区，东十二区和西十二区重合，所以一共是24个时区。 GMT和UTCGMT： 即格林威治时间（Greenwich Mean Time），也是0时区的标准时间。指太阳横穿格林威治子午线（本初子午线）时的时间。但由于地球自转不均匀不规则，导致GMT不精确，现在已经不再作为世界标准时间使用。UTC： 即协调世界时间（Coordinated Universal Time）。UTC是以原子时秒长为基础，在时刻上尽量接近于GMT的一种时间计量系统。UTC现在作为世界标准时间使用。 所以，UTC与GMT基本上等同，误差不超过0.9秒。","pubDate":"Sun, 08 Mar 2020 14:08:10 GMT","guid":"https://janche.github.io/2020/03/08/UTC、GMT、时间戳之间的关系/","category":"时区"},{"title":"Java实现文件的压缩和在浏览器端下载","link":"https://janche.github.io/2020/03/08/Java实现文件的压缩和在浏览器端下载/","description":"压缩为zip文件1. 通过java程序输出文件123456789101112131415161718192021222324252627/** * 功能:压缩多个文件成一个zip文件 * @param srcfile：源文件列表 * @param zipfile：压缩后的文件 */public static void zipFiles(File[] srcfile, File zipfile) &#123; byte[] buf = new byte[1024]; try &#123; //ZipOutputStream类：完成文件或文件夹的压缩 ZipOutputStream out = new ZipOutputStream(new FileOutputStream(zipfile)); for (int i = 0; i &lt; srcfile.length; i++) &#123; FileInputStream in = new FileInputStream(srcfile[i]); // 给列表中的文件单独命名 out.putNextEntry(new ZipEntry(srcfile[i].getName())); int len; while ((len = in.read(buf)) &gt; 0) &#123; out.write(buf, 0, len); &#125; out.closeEntry(); in.close(); &#125; out.close(); System.out.println(\"压缩完成.\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;","pubDate":"Sun, 08 Mar 2020 14:05:14 GMT","guid":"https://janche.github.io/2020/03/08/Java实现文件的压缩和在浏览器端下载/","category":"文件下载,zip多文件压缩"},{"title":"spring-boot集成mybatis通用mapper和pagehelper","link":"https://janche.github.io/2019/10/07/spring-boot集成mybatis通用mapper和pagehelper/","description":"1. 项目所需依赖1234567891011121314151617181920&lt;!-- mybatis 依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mybatis pagehelper 分页插件 --&gt;&lt;dependency&gt;&lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.10&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mybatis 通用mapper --&gt;&lt;dependency&gt;&lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.5&lt;/version&gt;&lt;/dependency&gt;","pubDate":"Mon, 07 Oct 2019 11:23:06 GMT","guid":"https://janche.github.io/2019/10/07/spring-boot集成mybatis通用mapper和pagehelper/","category":"springboot,mybatis,pagehelper"},{"title":"基于Spring-Security-OAuth2的SSO单点登录（客户端）","link":"https://janche.github.io/2019/10/07/基于Spring-Security-OAuth2的SSO单点登录（客户端）/","description":"单点登录（服务端）：https://blog.csdn.net/qq_34997906/article/details/97007709 1. 缘起为什么要把客户端单独拿出来写呢 ？博主也参考了网上很多写单点登录的，但基本上都是大同小异，在客户端的自身权限校验 和 单点退出 均未做处理，显然并不满足实际的业务开发。 2. 核心流程 客户端登录：用户访问客户端，客户端 security 发现此请求的用户未登录，于是将请求重定向到服务端认证，服务端检测到此请求的用户未登录，则将此请求跳转到服务端提供的登录页面(前后端分离则是前端登录地址，否则为服务端内置的登录页面)，登录成功后，服务端将系统的权限信息（为了减轻服务端的访问压力）和用户的特有标志（如用户名，记录此用户的登录状态）存入redis，然后服务端会跳回到用户第一次访问客户端的页面。 客户端URL的拦截：每次请求到来时，客户端都去Redis中去取认证中心存入的权限信息和用户特有的登录标志，权限信息只是为了匹配此登录用户是否有权利访问此接口，用户的特有标志则是为了检测该用户是否在其他客户端退出了，如若没有取到，则重定向到服务端的登录页面。","pubDate":"Mon, 07 Oct 2019 11:21:10 GMT","guid":"https://janche.github.io/2019/10/07/基于Spring-Security-OAuth2的SSO单点登录（客户端）/","category":"spring-security,OAuth2,SSO"},{"title":"基于Spring Security + OAuth2的SSO单点登录（服务端）","link":"https://janche.github.io/2019/10/07/基于Spring-Security-OAuth2的SSO单点登录（服务端）/","description":"相关技术 spring security： 用于安全控制的权限框架 OAuth2： 用于第三方登录认证授权的协议 JWT：客户端和服务端通信的数据载体 传统登录登录web系统后将用户信息保存在session中，sessionId写入浏览器的cookie中，每次访问系统，浏览器自动携带此cookie，服务端根据此sessionId取到相应的session，若为空则表示登录已失效，不为空则表示用户已登录，不需要用户再次输入用户名密码。 单点登录单点登录是一种多站点共享登录访问授权机制，访问用户只需要在一个站点登录就可以访问其它站点需要登录访问的资源(url)。用户在任意一个站点注销登录，则其它站点的登录状态也被注销。简而言之就是：一处登录，处处登录。一处注销，处处注销。spring-security + OAuth2 完美解决了完全跨域的问题。","pubDate":"Mon, 07 Oct 2019 11:17:50 GMT","guid":"https://janche.github.io/2019/10/07/基于Spring-Security-OAuth2的SSO单点登录（服务端）/","category":"spring-security,OAuth2,SSO"},{"title":"Spring Security + JWT 完成RBAC动态授权","link":"https://janche.github.io/2019/07/24/Spring-Security-JWT-完成RBAC动态授权/","description":"此篇文章为spring security系列的第一篇，着重讲解如何通过spring security完成企业级项目的权限控制，以及采用Redis的方式控制JWT的失效。 1. 什么是RBACRBAC（Role-Based Access Control ）基于角色的权限控制，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。 2. JWT 和 Spring Securityspring security 授权主要分为两种，一种是security内部负责维护登录用户的session，一种则是采用JWT的方式，不管理session。关于JWT 和 Security的详细资料请小伙伴们自行查阅（相关网址推荐：http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html）此处就不在赘述，好了下面开始正文吧。","pubDate":"Wed, 24 Jul 2019 11:49:19 GMT","guid":"https://janche.github.io/2019/07/24/Spring-Security-JWT-完成RBAC动态授权/","category":"spring-security,OAuth2,jwt"},{"title":"Hexo(yilia)+Github实现相册和音频功能","link":"https://janche.github.io/2019/06/16/Hexo-Github实现相册和音频功能/","description":"效果图，请先点这里：https://janche.github.io/photos/ 1. 需要准备的资料 1. 本文为hexo-theme-yilia主题，其他hexo主题请另行百度2. GitHub上新建一个仓库存储照片（此仓库的作用除了储存还负责更新hexo博客引用的图片链接地址），为了少走弯路，请直接fork原作者的仓库(https://github.com/lawlite19/Blog-Back-Up.git)，若下载速度太慢，可选择我的备用地址(https://github.com/Janche/Blog-Photo.git)3. Python环境（安装Python3，并配置环境变量，对照片的处理是通过Python命令来处理的）4. 在你的hexo博客的source文件夹下(注意不是yilia主题下的source)，新建一个photos文件夹,用于存放照片相关的文件， 也可通过命令 hexo new page photos创建","pubDate":"Sun, 16 Jun 2019 15:07:56 GMT","guid":"https://janche.github.io/2019/06/16/Hexo-Github实现相册和音频功能/","category":"hexo"},{"title":"Runtime 调用Process.waitfor导致的阻塞问题","link":"https://janche.github.io/2019/06/16/Runtime-调用Process-waitfor导致的阻塞问题/","description":"1. 关于Runtime类的小知识 1. Runtime.getRuntime()可以取得当前JVM的运行时环境，这也是在Java中唯一一个得到运行时环境的方法2. Runtime中的exit方法是退出JVM 2. Runtime的几个重要的重载方法","pubDate":"Sun, 16 Jun 2019 01:34:20 GMT","guid":"https://janche.github.io/2019/06/16/Runtime-调用Process-waitfor导致的阻塞问题/","category":"Runtime"},{"title":"为什么要使用serialVersionUID","link":"https://janche.github.io/2019/05/19/为什么要使用serialVersionUID/","description":"1. 序列化是什么 把对象转换为字节序列的过程称为对象的序列化 。 把字节序列恢复为对象的过程称为对象的反序列化。 2. Java中如何使用序列化只需要让对象实现 Serializable接口即可，如下：","pubDate":"Sun, 19 May 2019 09:53:52 GMT","guid":"https://janche.github.io/2019/05/19/为什么要使用serialVersionUID/","category":"序列化"},{"title":"spring-security对OAuth2的集成（数据库的方式）","link":"https://janche.github.io/2019/04/28/OAuth2/","description":"教程由来：项目需要为第三方客户端提供授权和资源访问，无疑OAuth2现在是最好的方式，如果OAuth2相关知识大家还不够了解，请移步到阮一峰的理解OAuth2.0，本文实战为主，理论方面请自行查阅相关资料。 1. OAuth2的四种模式 授权码模式（authorization code）(最正统的方式，也是目前绝大多数系统所采用的)(支持refresh token) (用在服务端应用之间) 密码模式（resource owner password credentials）(为遗留系统设计) (支持refresh token) 简化模式（implicit）(为web浏览器应用设计)(不支持refresh token) (用在移动app或者web app，这些app是在用户的设备上的，如在手机上调起微信来进行认证授权) 客户端模式（client credentials）(为后台api服务消费者设计) (不支持refresh token) (为后台api服务消费者设计) 本文采用数据库的方式对上述四种模式进行配置，网上绝大多数都是配置在内存中的demo，学习尚可，真实的开发环境却是还远远不够。","pubDate":"Sun, 28 Apr 2019 01:06:42 GMT","guid":"https://janche.github.io/2019/04/28/OAuth2/","category":"spring-security-oauth2,oauth2"},{"title":"mybatis的关联嵌套查询--分页详解","link":"https://janche.github.io/2019/04/26/mybatis的关联嵌套查询-分页详解/","description":"问题描述1. mybatis嵌套查询后，分页混乱：mybatis通过查询结果之后折叠结果集把数据放在了集合里,这就导致总条数的混乱.而第一种的方式是分两次查询，分页只针对第一次查询,就不会有分页的问题,所以解决方案就是把你的collection写成第一种的方式2. 折叠结果集映射不上数据","pubDate":"Fri, 26 Apr 2019 07:05:31 GMT","guid":"https://janche.github.io/2019/04/26/mybatis的关联嵌套查询-分页详解/","category":"mybatis,嵌套分页查询"},{"title":"docker部署springboot项目并连接mysql容器","link":"https://janche.github.io/2019/04/26/docker部署springboot项目并连接mysql容器/","description":"1. 先拉取mysql镜像(因为比较慢)docker pull mysql:5.7 2. 构建要部署的项目镜像2.1 创建一个目录","pubDate":"Fri, 26 Apr 2019 07:03:13 GMT","guid":"https://janche.github.io/2019/04/26/docker部署springboot项目并连接mysql容器/","category":"docker,springboot"},{"title":"基于OpenCV对图片清晰度、色偏和亮度的检测（java版）","link":"https://janche.github.io/2019/04/26/OpenCV/","description":"由来：近期项目需要检测图片的亮度和色偏，但网上大多为用C实现的，没有java版本的，此篇为java版本对opencv的调用，谨以此献给CSDN的广大用户。 一. 导入OpenCV所需依赖依赖下载：OpenCV运行环境下载(包含jar包和dll依赖库) 在IDEA的项目模块下新建一个libs目录，将opencv-343.jar放进去，将opencv_java343.dll放到项目下。","pubDate":"Fri, 26 Apr 2019 06:57:09 GMT","guid":"https://janche.github.io/2019/04/26/OpenCV/","category":"OpenCV,图像清晰度、亮度、色偏检测"},{"title":"springmvc-validator","link":"https://janche.github.io/2019/04/23/springmvc-validator/","description":"Spring Boot 数据校验框架 springmvc-validator 使用说明使用步骤 依赖 hibernate-validation,validation-api已经被添加在spring-boot-starter-web内，所以不需要添加依赖","pubDate":"Tue, 23 Apr 2019 14:04:55 GMT","guid":"https://janche.github.io/2019/04/23/springmvc-validator/","category":"springmvc,validator"},{"title":"随想录","link":"https://janche.github.io/2019/04/23/随想录/","description":"弦上的博客之第一篇，没有想象中的那么激情澎湃，或许成功喜悦的分量和过程艰辛的程度确是有很大关系，当然这很大程度上得感谢Hexo的开源，感谢我东哥的分享，在今后那些不曾起舞的日子里，愿我能常在此留下点滴的印记。","pubDate":"Tue, 23 Apr 2019 13:17:24 GMT","guid":"https://janche.github.io/2019/04/23/随想录/","category":"日志"}]}